package core.journal;


import core.journal.utils.Checksum;
import core.strategy.Strategy;
import core.strategy.StrategyManager;
import io.serialization.StatedExternalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import utils.Pair;

/**
 * A Journal is a log / registry which contains all information about a done backup.
 * There are 2 types of journal type: complete and partial
 *  - Partial Journal contains only the metadata of a single backup
 *  - Complete Journal contains the metadata of all made backups of a specific strategy.
 * 
 * Complete journal can be defined as the union of all partial journals of a strategy.
 * It is generated by making the union of the last complete journal with the last
 * partial journal. 
 * Storing the complete journal as a single file in disk is useful to have not to compute
 * it every time it is needed.
 * 
 * Journal uses an HashMap to improve the performance of a file search by filename.
 * The uniqueness of files in journal is defined by the use of checksum.
 * It is reasonable to defined a file by it's checksum considering the ultra low 
 * probability of two different files having the same checksum (See SHA256 papers).
 * The reason of having a list of checksum in the hashmap is to permit 2 file with
 * the same filename.
 * Journal does not store the structure of the sources of the backup (The absolute path
 * of the files) since this would make it complicate to work with the journal if the sources
 * are then renamed or moved.
 * 
 * Serialization
 * This class implements Externalizable in order to perform explicit serialization 
 * using read and write external methods. UPDATE these methods when the class is 
 * changed to assure compatibility through different software versions!
 * 
 * 
 * @author Fedrix
 * @see FileSystemTree
 */
public class Journal extends StatedExternalizable implements Iterable {
    private static final long serialVersionUID = 8L;
    public long strategyID;
    private LocalDateTime created;
    public JournalType type;
    protected HashMap<String, List<Checksum>> files; // Map: Filename -> List<SHA256>, Invariant: files.getValue(key).size() > 0, the list of checksum for a filename is always non empty
    private int size = 0;
    
    /**
     * Needed to make the class Externalizable (Serializable)
     * Warning: do not use or the state of the class will be corrupted
     */
    public Journal(){}
    
    /**
     * Journal contructor for a strategy and of a specific type
     * @param strategy
     * @param type 
     */
    public Journal(Strategy strategy, JournalType type){
        this.strategyID = strategy.getId();
        this.created = LocalDateTime.now();
        this.type = type;
        this.size = 0;
        files = new HashMap<>();
    }
    
    /**
     * Private constructor which is used by union operator
     * @param strategyID
     * @param type 
     */
    private Journal(long strategyID, JournalType type){
        this.strategyID = strategyID;
        this.created = LocalDateTime.now();
        this.type = type;
        this.size = 0;
        files = new HashMap<>();
    }
    
    private void addFile(Path file) throws IOException {
        assert(Files.isRegularFile(file));
        String filename = file.getFileName().toString();
        Object hashesObj = files.get(filename);
        List<Checksum> hashesList;
        if(hashesObj == null){
            hashesList = new ArrayList<>();
            hashesList.add(new Checksum(file));
            files.put(filename, hashesList);   
        } else {
            hashesList = (List<Checksum>) hashesObj;
            hashesList.add(new Checksum(file));
        }
        size++;
    }
    
    
    /**
     * Add a new file or folder to the journal
     * @param file
     * @throws IOException 
     */
    public void add(Path file) throws IOException {
        if(Files.isRegularFile(file)){
            addFile(file);
        } else if(Files.isDirectory(file)){
            Iterator<Path> it = Files.list(file).iterator();
            while(it.hasNext()){
                add(it.next());
            }
        }
    }
    
    /**
     * Remove a file from the journal.
     * If the file is accessible then the checksum is calculated in order to remove the specific checksum entry of the file.
     * If the file is not accessible then all checksum related to the filename of the file are removed.
     * @param file 
     */
    public void removeFile(Path file){
        assert(Files.isRegularFile(file));
        String filename = file.getFileName().toString();
        Object checksumObject = files.get(filename);
        if(checksumObject != null){
            List<Checksum> checksums = (List<Checksum>) checksumObject;
            for(var checksum : checksums){
                try {
                    if(checksum.isOf(file)){
                        checksums.remove(checksum);
                        break; //There cannot be 2 same checksum in checksums list
                    }
                } catch (IOException ex) {
                    files.remove(filename);
                    break;
                }
            }
        }
    }
    
    /**
     * @return a copy of the hash map used by the journal
     */
    protected Map<String, List<Checksum>> getHashmap(){
       return Map.copyOf(files);
    }
    
    /**
     * Check if a file is in the journal by using it's filename.
     * It efficiently compares chunks of file data using SHA256.
     * @param file
     * @return A pair containing an information about the existence of the file 
     * in the journal and the reference to the checksum which verified the file.
     * The Checksum object is null if the file was not found in the journal.
     * @throws java.io.IOException 
     */
    public Pair<Boolean, Checksum> has(Path file) throws IOException {
        assert(Files.isRegularFile(file));
        String filename = file.getFileName().toString();
        Object checksumObject = files.get(filename);
        if(checksumObject == null)
            return new Pair<>(false, null);
        List<Checksum> checksums = (List<Checksum>) checksumObject;
        for(var checksum : checksums){
            if(checksum.isOf(file)){
                return new Pair<>(true, checksum);
            }
        }
        return new Pair<>(false, null);
    }
    
    /**
     * @return number of entries in journal
     */
    public int size(){
        return size;
    }
    
    public boolean isEmpty(){
        return size == 0;
    }
    
    public LocalDateTime getCreatedTime(){
        return created;
    }
    
    
    /**
     * Union between journal
     * Used to make a complete journal containing all entries of partial journals.
     * @param toUnion
     * @return always a journal of type complete
     */
    public Journal union(Journal... toUnion){
        Journal complete = new Journal(strategyID, JournalType.COMPLETE);
        complete.files.putAll(this.files);
        complete.size = this.size;
        for(Journal partial : toUnion){
            if(complete.strategyID != partial.strategyID)
                throw new IllegalArgumentException("Passed journal must match the strategy id of this journal.");
            for(var filename : partial.files.keySet()){
                var newChecksumList = partial.files.get(filename);
                var oldChecksumList = complete.files.get(filename);
                if(oldChecksumList == null){ // Filename is a new file
                    complete.size += newChecksumList.size();
                    complete.files.put(filename, newChecksumList);
                } else { // New or modified filename
                    for(var checksum : newChecksumList){
                        if(!oldChecksumList.contains(checksum)){
                            complete.size++;
                            oldChecksumList.add(checksum);
                        }
                    }
                }
            }
        }
        return complete;
    }
    
    /**
     * Union between journal
     * Used to make a complete journal containing all entries of partial journals.
     * @param journals
     * @return always a journal of type complete
     */
    public Journal union(List<Journal> journals){
        return union((Journal[]) journals.toArray());
    }
    
    @Override
    public String toString(){
        StringBuilder sb = new StringBuilder();
        sb.append("-- %s journal size %s created on %s --".formatted(strategyID, size, (created != null) ? created : "NullDatetime"));
        sb.append(System.lineSeparator());
        for(var filename : files.keySet()){
            sb.append(filename);
            sb.append(" <> ");
            sb.append(files.get(filename));
            sb.append(System.lineSeparator());
        }
        return sb.toString();
    }

    @Override
    public Iterator<JournalEntry> iterator() {
        return new JournalIterator(this);
    }

    @Override
    public void writeExternal(ObjectOutput out) throws IOException {
        out.writeInt(size);
        out.writeObject(created);
        out.writeObject(type);
        out.writeObject(files);
        out.writeLong(strategyID);
    }

    @Override
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
        this.size = in.readInt();
        this.created = (LocalDateTime) in.readObject();
        this.type = (JournalType) in.readObject();
        this.files = (HashMap<String, List<Checksum>>) in.readObject();
        this.strategyID = in.readLong();
        super.reachedEOF = false;
    }

    
}
